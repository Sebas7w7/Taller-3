/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package taller

import org.scalameter._
import common._
import taller.Taller3
import scala.util.Random
import scala.collection.parallel.immutable.ParVector
import scala.util.Random
object App {

  // Definimos un tipo alias para representar una matriz como un vector de vectores.
  type Matriz = Vector[Vector[Int]]

  // Método principal de entrada del programa.
  def main(args: Array[String]): Unit = {
    println(greeting())
    // Inicia las pruebas de rendimiento para diferentes operaciones matemáticas.
    println("\n....... Iniciando benchmarking .......")
    benchmarkingVectores()
    benchmarkingMultMatriz()
    benchmarkingMultMatrizRec()
    benchmarkingMultStrassen()
  }
  def greeting(): String = "Hello, World!"

  // Método para realizar el benchmarking de la operación de producto punto de vectores.
  def benchmarkingVectores(): Unit = {
    val taller = new Taller3() // Instancia de la clase que contiene las implementaciones de las operaciones.
    println("\n------------- Benchmarking: Producto Punto de Vectores ----------------")
    // Iteramos desde tamaños pequeños hasta tamaños más grandes, aumentando exponencialmente
    for (i <- 1 to 10) {
      // Generamos dos vectores de tamaño 2^i con números aleatorios.
      val tamaño = math.pow(2, i).toInt // Genera el tamaño del vector como una potencia de 2.
      val vector1: Vector[Int] = Vector.fill(tamaño)(Random.nextInt())
      val vector2: Vector[Int] = Vector.fill(tamaño)(Random.nextInt())

      println(f"\n ------ | Iteración $i: Tamaño Vector = ${tamaño} | ------")
      // Compara las versiones secuencial y paralela del producto punto.
      taller.compararProdPunto(taller.prodPunto, taller.prodPuntoParD, "Secuencial", "Paralelo")(vector1, vector2)
    }
  }
  
 // Benchmarking de la multiplicación de matrices (secuencial vs paralelo).
  def benchmarkingMultMatriz(): Unit = {
    val taller = new Taller3()
    println("\n------------- Benchmarking: Multiplicación de Matrices Secuencial y Paralela ----------------")
    //  Realiza pruebas con las dos implementaciones (secuencial y paralela).
    realizarBenchmarking(taller, 7, taller.multMatriz, taller.multMatrizPar, "Secuencial", "Paralelo")
  }
  
  // Benchmarking de la multiplicación de matrices (recursiva) (secuencial vs paralelo).
  def benchmarkingMultMatrizRec(): Unit = {
    val taller = new Taller3()
    println("\n------------- Benchmarking: Multiplicación Recursiva de Matrices Secuencial y Paralela ----------------")
    // Realiza pruebas con las dos implementaciones (secuencial y paralela).
    realizarBenchmarking(taller, 7, taller.multMatrizRec, taller.multMatrizRecPar(_, _, 64), "Secuencial", "Paralelo")
  }

  // Benchmarking de la multiplicación de matrices con el algoritmo de Strassen (secuencial vs paralelo).
  def benchmarkingMultStrassen(): Unit = {
    val taller = new Taller3()
    println("\n------------- Benchmarking: Multiplicación de Matrices con Algoritmo de Strassen ----------------")
    // Realiza pruebas con las dos implementaciones (secuencial y paralela).
    realizarBenchmarking(taller, 7, taller.multStrassen, taller.multStrassenPar, "Secuencial", "Paralelo")
  }

  // Método auxiliar para realizar el benchmarking de las operaciones de multiplicación de matrices.
  def realizarBenchmarking(
    
    taller: Taller3, // Instancia de la clase que contiene las implementaciones de las operaciones.
    iteraciones: Int, // Número de iteraciones a realizar.
    funcionSecuencial: (Matriz, Matriz) => Matriz, // Función secuencial a evaluar.
    funcionParalela: (Matriz, Matriz) => Matriz, // Función paralela a evaluar.
    nombreSecuencial: String, 
    nombreParalelo: String
  ): Unit = {
    // Iteramos desde tamaños pequeños hasta tamaños más grandes, aumentando exponencialmente.
    for (i <- 1 to iteraciones) {
      // Generamos dos matrices de tamaño 2^i con números aleatorios.
      val tamaño = math.pow(2, i).toInt
      val matriz1 = taller.matrizAlAzar(tamaño, 2)
      val matriz2 = taller.matrizAlAzar(tamaño, 2)

      // Imprimimos el tamaño de la matriz actual.
      println(f"\n ------ | Iteración $i: Tamaño Matriz = [${tamaño} x ${tamaño}] | ------")
      // Comparamos las versiones secuencial y paralela de la multiplicación de matrices.
      taller.compararAlgoritmos(funcionSecuencial, funcionParalela, nombreSecuencial, nombreParalelo)(matriz1, matriz2)
    }
  }
}